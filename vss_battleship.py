from redisvl.index import SearchIndex
import redis
from redis.commands.search.query import Query
import yaml,sys,getopt,random 
import numpy as np

def load_schema_definition():
    #Get the schema definition loaded from the yaml file:
    with open('vss_battleship_schema.yaml', 'r') as file:
        search_schema = yaml.safe_load(file)
    print()
    print(type(search_schema))
    return search_schema

def initialize_redis_index(host,port,search_schema):
    # initialize the connection to Redis
    connection_string = "redis://"+host+":"+port
    #connection_string = "rediss://default:Tw6ILWm45CnQ36Iuu9HeGkmLuNm96vEOz8e818yd4Mw=@redisDB.southcentralus.redisenterprise.cache.azure.net:10000"    
    index = SearchIndex.from_dict(search_schema)
    index.connect(connection_string)
    return index

def create_index(index):
    index.create(overwrite=True)
    
def make_ship_shape_from_anchorXY(anchorX,anchorY):
    anchorX=int(anchorX)
    anchorY=int(anchorY)
    print(f' Target generated ship has anchorX of {anchorX} and anchorY of {anchorY}')
    ship_shape_point_pairs=np.empty(28, dtype=np.dtype('f')) 
    # make the ship cigar-shaped first by increasing the X distance 
    # between each pointXY1 and pointXY2 before doing the opposite
    for point_pair in range(1,14):
        pointXY1 = ((10)+anchorX+anchorY+(point_pair*10))/100000
        pointXY2 = (((10)+anchorX+(point_pair*10))+anchorY+(point_pair*10))/100000        
        ship_shape_point_pairs[point_pair]=(pointXY1*pointXY2)       
    for point_pair in range(1,14):
        pointXY1 = ((10)+anchorX+anchorY+((point_pair+14)*10))/100000
        pointXY2 = (((10)+anchorX-(point_pair*10))+anchorY+((point_pair+14)*10))/100000
        ship_shape_point_pairs[point_pair+14]=(pointXY1*pointXY2)
    print(f'ship_shape_point_pairs length = {len(ship_shape_point_pairs)}')
    thing = np.array(ship_shape_point_pairs, dtype=np.float32).tobytes()
    print(f'np.array result is of type: {type(thing)}')
    return (thing)

# in this game a non-player role (the user) guesses the anchor point and
# player_ID: either 'player1' or 'player2'
# this function generates a ship for a random player with random anchors
def create_data():
# create some dummy data: (can be called repeatedly to generate more data)
    # Each ship has 28 pairs of X,Y coordinates that define 
    # its shape & placement 
    # smaller ships have points that are closer together 
    # for simplicity, let's start with two ships
    # they will be between 200 and 500 measures apart
    # a measure is the standard distance between point aX,aY and bX,bY
    # for this initial game we will make that measure 10 
    # for large ships and 3 for small ships
    # Vector Similarity expects floating point values
    # so we divide each point value by 100000
    # start with an anchor point for each ship
    # anchor values fall between 200,501 and 500,1100
    player_num = random.randint(1,2)
    battle_ship_classes =['Destroyer','Aircraft_Carrier','Skiff','Submarine']
    anchorX = (random.randint(200,500))
    anchorY = (random.randint(1,100)+(player_num*500))
    player_ID = f'player{str(player_num)}'
    data = [
        {
            "player_ID": player_ID,
            "battlehip_class": battle_ship_classes[random.randint(1,3)],
            "coordinates_embedding": make_ship_shape_from_anchorXY(anchorX,anchorY),
        },
    ]

    print("Dummy Ship shape_and_coordinates created! - here is a sample of one of the elements and it's length:")
    print([value for value in data[0].values()][1])
    print()
    print(len([value for value in data[0].values()][1]))
    print()
    return data

# load data into the index in Redis (list of dicts)
def load_data(index,data):
    index.load(data)

# this function executes the VSS search call against Redis
# it accepts a redis index (generated by calling connection)
def vec_search(vindex,query_vector_as_bytes):
    print(f'\nvec_search() --> vindex is of type: {type(vindex)}  embedding is of type: {type(query_vector_as_bytes)}')
    # KNN 10 specifies to return only up to 10 nearest results (could be unrelated)
    # VECTOR_RANGE specifies the prompts must be similar
    query =(
        Query(f'(@coordinates_embedding:[VECTOR_RANGE .000000002 $vec_param]=>{{$yield_distance_as: range_dist}})=>[KNN 10 @coordinates_embedding $knn_vec]=>{{$yield_distance_as: knn_dist}}')
        .sort_by(f'knn_dist') #asc is default order
        .return_fields("player_ID", "battlehip_class", "knn_dist")
        .dialect(2)
    )
    res = vindex.search(query, query_params = {'vec_param': query_vector_as_bytes, 'knn_vec': query_vector_as_bytes})
    return res.docs

# start with an anchor point for each ship
# anchor values fall between 200,501 and 500,1100
# also search by player_num 1 or 2: 
def do_search_query(index,anchorX,anchorY,player_num):
    #filterexpres = ("player_ID") == f'player{str(player_num)}'
    print(f'query is--> \nplayer_ID is player{str(player_num)}')
    print(f'anchorX == {anchorX}  anchorY == {anchorY} ')
    vector=make_ship_shape_from_anchorXY(anchorX,anchorY)
    results = vec_search(index,vector)
    print(f'\nQuery Results have a length of {len(results)}')
    return results

if __name__ == "__main__":
    print(f'MAIN FUNCTION CALLED')
    # TODO: edit or supply as args the host and port to match your redis database endpoint:
    host="localhost"
    port="6379"
    createNewIndex = False
    loadData = False
    testQuery = False
    user_choice ='n'
    argv = sys.argv[1:] # skip the name of this script
    opts,args = getopt.getopt(argv,"h:p:c:l:t:", 
                                   ["host =",
                                    "port =",
                                    "create_new_index =",
                                    "load_data =",
                                    "test_query ="
                                    ]) 
    for opt,arg in opts:
        if opt in ['-h','-host']:
            host = arg
        elif opt in ['-p','-port']:
            port = arg
        elif opt in ['-c','--create_new_index']:
            user_choice = arg
            print(f'user_choice for {opt} == {user_choice}')                 
            if user_choice == 'y':
                 print(f'user_choice for {opt} == {user_choice}')
                 createNewIndex = True
        elif opt in ['-l','--load_data']:
            user_choice = arg
            if user_choice == 'y':
                 print(f'user_choice for {opt} == {user_choice}')
                 loadData = True
        elif opt in ['-t','--test_query']:
            user_choice = arg
            if user_choice =='y':
                print(f'user_choice for {opt} == {user_choice}')
                testQuery = True            
    if len(sys.argv)<6:
        print('\nPlease supply a hostname & port for your target Redis instance:\n')
        print('\n\tYour options are: ')
        print('-h <host> -p <port> -create_new_index y/n -load_data y/n -test_query y/n')
        print('(unassigned options default to not being enabled)')
        exit(0)
    if len(sys.argv)>5:
        #try:
            search_schema = load_schema_definition()
            print("search_schema loaded")
            print(f"\nconnecting to: host={host} port={port} ...")
            rindex = initialize_redis_index(host,port,search_schema)
            if createNewIndex:
                print('creating a new index in redis...')
                create_index(rindex)
            if loadData:
                print('loading data into redis...')
                load_data(rindex,create_data())
            if testQuery:
                print('Executing a test query against the redis search index...\n\tRESULT:\n')
                anchorX = input("enter an integer between 200 and 500 for target X coordinate :   ")
                anchorY = input("enter an integer between 501 and 1100 for target Y coordinate :   ")
                player_num = input("enter an integer between 1 and 2 for target player_num :   ")
                qresults = do_search_query(index=rindex,anchorX=anchorX,anchorY=anchorY,player_num=player_num)
                for r in qresults:
                    print(f'\nHere are the ships you HIT...:\n {r}')
                print('\n\nexiting ...')
        #except Exception as e:
         #   print(f'You may need more data loaded,\n or... You may need to provide different command line arguments for your host and port, etc')
          #  print(e)
